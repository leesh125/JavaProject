-- JOIN : 2개 이상의 테이블에서 데이터를 조회하기 위해 사용하는 구문
--        집합 구문과는 다르게 쿼리 결과에 대한 무조건적인 집합(쿼리)셋을 구하는 것이 아닌
--        쿼리 결과에 대한 결합 조건이 있다.
--        집합 구문은 행(로우) 데이터에 대한 추가가 이루어 지지만. JOIN 은 열(컬럼) 데이터에 대한
--        추가가 이루어 진다.
SELECT *
  FROM EMPLOYEES JOIN DEPARTMENTS
    ON (EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID);

-- 조인을 수행하는 테이블의 컬럼이 동일한 이름을 사용하는 경우 테이블명.컬럼명 으로 구분시킨다.
SELECT EMPLOYEES.EMPLOYEE_ID AS 사원코드
     , CONCAT(EMPLOYEES.FIRST_NAME, ' ' || EMPLOYEES.LAST_NAME) AS 사원명
     , EMPLOYEES.DEPARTMENT_ID AS 부서코드
     , DEPARTMENTS.DEPARTMENT_NAME AS 부서명
  FROM EMPLOYEES JOIN DEPARTMENTS
    ON (EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID);

-- 테이블명에 별칭을 부여할 수 있음.
SELECT A.EMPLOYEE_ID AS 사원코드
     , CONCAT(A.FIRST_NAME, ' ' || A.LAST_NAME) AS 사원명
     , A.DEPARTMENT_ID AS 부서코드
     , B.DEPARTMENT_NAME AS 부서명
  FROM EMPLOYEES A JOIN DEPARTMENTS B
    ON (A.DEPARTMENT_ID = B.DEPARTMENT_ID);

-- 조인 조건의 컬럼명이 동일한 경우 USING 을 사용하여 결합시킬 수 있다.
SELECT A.EMPLOYEE_ID AS 사원코드
     , CONCAT(A.FIRST_NAME, ' ' || A.LAST_NAME) AS 사원명
     , DEPARTMENT_ID AS 부서코드
     , B.DEPARTMENT_NAME AS 부서명
  FROM EMPLOYEES A JOIN DEPARTMENTS B
 USING (DEPARTMENT_ID);


-- 2개 이상의 테이블에 대한 조인
SELECT A.EMPLOYEE_ID AS 사원코드
     , CONCAT(A.FIRST_NAME, ' ' || A.LAST_NAME) AS 사원명
     , DEPARTMENT_ID AS 부서코드
     , B.DEPARTMENT_NAME AS 부서명
     , JOB_ID AS 직업코드
     , C.JOB_TITLE AS 직업명
  FROM EMPLOYEES A JOIN DEPARTMENTS B
 USING (DEPARTMENT_ID)
  JOIN JOBS C
 USING (JOB_ID);


-- 아래의 테이블의 DEPARTMENT_NO, COACH_PROFESSOR_NO 를 활용하여 학과명, 교수명 컬럼이
-- 조회될 수 있도록 JOIN 을 사용
SELECT A.STUDENT_NO
     , A.STUDENT_NAME
     , A.DEPARTMENT_NO
     , B.DEPARTMENT_NAME
     , A.COACH_PROFESSOR_NO
     , C.PROFESSOR_NAME
  FROM TB_STUDENT A JOIN TB_DEPARTMENT B
    ON A.DEPARTMENT_NO = B.DEPARTMENT_NO
  JOIN TB_PROFESSOR C
    ON A.COACH_PROFESSOR_NO = C.PROFESSOR_NO;


-- OUTER JOIN : 일반 JOIN 과는 다르게 결합 조건에 부합하는 데이터가 없어도 조회 결과로 나올 수
--              있게 한다. 왼쪽 테이블을 기준으로 조회결과가 나오게 할때에는 LEFT OUTER JOIN
--              오른쪽 테이블을 기준으로 조회결과가 나오게 할떄에는 RIGHT OUTER JOIN
SELECT EMPLOYEE_ID
     , FIRST_NAME
     , LAST_NAME
     , DEPARTMENT_ID
  FROM EMPLOYEES WHERE EMPLOYEE_ID BETWEEN 175 AND 180;

SELECT A.EMPLOYEE_ID
     , A.FIRST_NAME
     , A.LAST_NAME
     , A.DEPARTMENT_ID
     , B.DEPARTMENT_NAME
  FROM EMPLOYEES A JOIN DEPARTMENTS B
    ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
 WHERE A.EMPLOYEE_ID BETWEEN 175 AND 180;

SELECT A.EMPLOYEE_ID
     , A.FIRST_NAME
     , A.LAST_NAME
     , A.DEPARTMENT_ID
     , B.DEPARTMENT_NAME
  FROM EMPLOYEES A LEFT OUTER JOIN DEPARTMENTS B
    ON A.DEPARTMENT_ID = B.DEPARTMENT_ID
 WHERE A.EMPLOYEE_ID BETWEEN 175 AND 180;


WITH L_TB AS (
    SELECT 1 AS ID, '가' AS NAME FROM DUAL
    UNION ALL
    SELECT 2 AS ID, '나' AS NAME FROM DUAL
    UNION ALL
    SELECT 3 AS ID, '다' AS NAME FROM DUAL
), R_TB AS (
    SELECT 1 AS ID, '라' AS NAME FROM DUAL
    UNION ALL
    SELECT 2 AS ID, '마' AS NAME FROM DUAL
    UNION ALL
    SELECT 4 AS ID, '바' AS NAME FROM DUAL
)
SELECT *
  FROM L_TB A CROSS JOIN R_TB B;
    -- ON A.ID = B.ID; 

-- NON_EQU JOIN : 일정 범위에 해당하는 여를 기준으로 조인을 하는 형식
SELECT A.EMPLOYEE_ID,
       A.FIRST_NAME,
       A.LAST_NAME,
       A.SALARY,
       B.JOB_ID,
       B.JOB_TITLE
  FROM EMPLOYEES A JOIN JOBS B
    ON A.SALARY BETWEEN B.MIN_SALARY AND B.MAX_SALARY
 ORDER BY 1;

--SELF JOIN : 서로 다른 테이블간
SELECT A.EMPLOYEE_ID AS 사번,
       A.FIRST_NAME || ' ' || A.LAST_NAME AS 사원명,
       B.MANAGER_ID AS 관리자사번,
       B.FIRST_NAME || ' ' || B.LAST_NAME AS 관리자명
  FROM EMPLOYEES A JOIN EMPLOYEES B
    ON A.MANAGER_ID = B.EMPLOYEE_ID
 ORDER BY 1;

SELECT * FROM JOBS;
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, MANAGER_ID FROM EMPLOYEES; 
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME FROM EMPLOYEES; 

SELECT * FROM TB_CLASS;
SELECT * FROM TB_CLASS WHERE PREATTENDING_CLASS_NO IS NOT NULL;
SELECT * FROM TB_STUDENT;
SELECT * FROM TB_GRADE;
SELECT * FROM TB_PROFESSOR;
SELECT * FROM TB_DEPARTMENT;
SELECT * FROM TB_CLASS_PROFESSOR;

-- 교수별 담당 과목수가 얼마나 되는지 해당 교수의 이름과 같이 조회
SELECT P.PROFESSOR_NAME AS 교수명,
       P.PROFESSOR_NO AS 교수코드,
       COUNT(CLASS_NO) AS 총과목수
  FROM TB_PROFESSOR P JOIN TB_CLASS_PROFESSOR CP
    ON P.PROFESSOR_NO = CP.PROFESSOR_NO
 GROUP BY P.PROFESSOR_NAME, P.PROFESSOR_NO;
      
-- 학과별 배정된 교수의 인원이 얼마나 되는지 해당 학과명과 같이 조회
SELECT D.DEPARTMENT_NAME AS 학과,
       D.DEPARTMENT_NO AS 학과번호,
       COUNT(PROFESSOR_NO) AS 학과별교수인원
  FROM TB_DEPARTMENT D JOIN TB_PROFESSOR P
    ON D.DEPARTMENT_NO = P.DEPARTMENT_NO
 GROUP BY D.DEPARTMENT_NAME, D.DEPARTMENT_NO;

-- 모든 학생들의 학점을 출력하시오(단, 코드가 아닌 식별가능한 이름으로 출력)
SELECT S.STUDENT_NAME AS 이름,
       S.STUDENT_NO AS 학번,
       AVG(POINT) AS 학점평균
  FROM TB_STUDENT S JOIN TB_GRADE G 
    ON S.STUDENT_NO = G.STUDENT_NO
 GROUP BY  S.STUDENT_NAME, S.STUDENT_NO
 ORDER BY 1;
       
SELECT S.STUDENT_NAME AS 이름,
       S.STUDENT_NO AS 학번,
       G.CLASS_NO AS 과목번호,
       C.CLASS_NAME AS 과목이름,
       G.POINT AS 학점
  FROM TB_STUDENT S INNER JOIN TB_GRADE G 
    ON S.STUDENT_NO = G.STUDENT_NO INNER JOIN TB_CLASS C
    ON G.CLASS_NO = C.CLASS_NO
 GROUP BY  S.STUDENT_NAME, S.STUDENT_NO, G.CLASS_NO, C.CLASS_NAME, G.POINT
 ORDER BY 1;